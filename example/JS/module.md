**前端模块化**

1. 什么是模块？

   想象一下单片机板子，不同型号的板子功能是不一样的，而且暴露了一些接口去使得可以调用这些接口实现一些功能。模块也是如此，将一个复杂的程序按一定的规则封装成几个文件或块，然后组合在一起，模块内部私有，只暴露一些外部接口以供调用。

2. 模块化的好处

   避免污染命名空间

   更易分离，按需加载，依赖更清晰

   高复用性和可维护性

3. 多个JS文件引入带来的问题

   依赖模糊

   资源请求增多

   难以维护

4. **模块化规范**

   **CommonJS**

   在服务器端，运行时同步加载，在浏览器端，会提前编译打包处理，一个文件即是一个模块。

   基本语法：

   `module.exports = {}/ exports.xxx = value/ require()`

   CommonJS规范规定，每个模块内部，module变量代表当前模块，这个变量是一个对象，它的exports属性即是对外的接口

   ```javascript
   // example.js
   let a = 1
   let add = function(x) {
     return x + a
   }
   module.exports.a = a
   module.exports.add = add // 输出了变量a 和 函数 add
   ```

   使用时

   ```javascript
   const example = require(./example.js)
   example.a // 1
   example.add(2) // 3
   ```

   require的基本功能是：读入并执行一个JS文件，然后返回该模块的exports对象，若未发现该模块则报错

   加载机制：输入的是被输出的值的拷贝，就是说只要你输出了一个值，任凭你怎么通过外部去改内部的值，内部值都不会变。

   ***

   **AMD**

   由于CommonJS是同步加载的，就是说没加载完就不会执行后面的操作，所以并不适合浏览器端，而对于NodeJs适用的服务器编程，模块文件一般都存在本地了，加载起来也会比较快，也就没有了要同步的需求。但是浏览器端要求，要从服务器加载模块，就必须采用非同步模式，故浏览器环境一般采用AMD规范。

   AMD模式还可以实现动态加载

   ***

   **CMD**

   其结合了前两者的优点，`seajs`中所有模块都遵循CMD规范

   缺点：依赖`SPM`打包，模块加载逻辑偏重

   ***

   **ES6模块加载**

   `import / export default function(){}`需要知道函数名或变量名，否则无法加载，ES6模块输出的是**值的引用**而不是**值的拷贝**，相比CommonJs的运行时加载，ES6模块是编译时加载

   运行机制也有所不同，ES6模块使用动态引用，且不会缓存值，模块的变量值绑定在其所在的模块上

5. **总结**

   CommonJS因为是同步加载，可以用在服务端，但是浏览器端不行。

   因此有了AMD和CMD的解决方案，AMD可以用于浏览器，但是阅读和书写(define & require)都比较困难。

   CMD和AMD一样都使用于浏览器编程，依赖就近，延迟执行，对NodeJs而言很好用，但是打包有障碍。

   最终的ES6模块方式，对服务器端和浏览器端都可以是解决方案，并且在了语言标准层面的实现了模块化功能。
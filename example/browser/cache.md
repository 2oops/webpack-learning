1. 数据请求的步骤：发起请求 => 后端处理 => 浏览器响应

2. 缓存位置：

     Service Worker

       Memory Cache

       Disk Cache

       Push Cache

  3. Service Worker

       其中涉及到请求拦截，故须使用HTTPS，与浏览器内置缓存有所不同，Service worker可以自由控制缓存文件，匹配

       和读取缓存，并且是持续性的。

        使用：先注册，后监听install事件，后即可缓存需要的文件；若service worker没有命中缓存，则按缓存优先级获取数

       据，但浏览器最终显示的还是从servie worker中获取的数据。

  4. Memory Cache

       读取比磁盘缓存快，主要缓存的是当前页面的样式/脚本/图片等，读取高效但是可持续性很短，随着页面的关闭会关

       闭线程，内存中的缓存也随即失效。

       tips: 内存缓存不关心HTTP的cache-control的值，校验可能会对多个参数的特征进行校验。

  5. Disk Cache

       与内存缓存的区别在于时效更长和容量更大。

       根据请求头字段判断哪些数据需要缓存，大文件一般不进内存而进磁盘，内存使用率高时，一般会使用磁盘

  6. Push Cache

       Http/2中内容，当前面三种方法都没有命中缓存时，才会被使用，只在会话中存在，会话关闭则释放缓存，缓存时间

       短（5M），并非严格遵守请求头字段要求的缓存条件，且缓存的内容只能被使用一次。

7. 浏览器缓存策略一般分为两种：强缓存和协商缓存，且基本都是通过请求头来设置的。

     (根据客户端是否要向服务器重新发起HTTP请求区分)

8. 缓存过程：

     浏览器每次发起HTTP请求之前都会在缓存中查找结果和缓存标识；

     浏览器每次拿到请求结果之后都会将需要缓存的结果和缓存标识放入到缓存中；

9. 强缓存
     network -> served from momory cache/ served form disk cache

     强缓存可以通过设置请求头的 expires 和 cache control 实现

     1. Expires 

        Http/1 的产物，但受限于本地时间，本地时间修改后，缓存可能失效。表示在这个时间点后，需要重新请求。

        这是一种过时的产物，现在还配置这个参数多为了兼容。

     2. Cache Control

        Http/1.1 ，主要用于控制网页缓存，

        Cache-Control: max-age=300; 即表示这个请求的正确返回后的5分钟内如果再要获取这个数据就会命中该缓存。
   
        Cache-control设置
   
        | 参数           | 作用                                                         |
        | -------------- | ------------------------------------------------------------ |
        | public         | 响应可以被客户端和代理服务器缓存                             |
        | private        | 响应只可以被客户端缓存                                       |
        | max-age = 30   | 缓存30秒后就过期，需重新请求                                 |
        | s-maxage = 30  | 覆盖max-age，只在代理服务器中生效                            |
        | no-store       | 不缓存任何响应，都从服务器获取                               |
        | no-cache       | 可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用 |
        | max-stale = 30 | 30秒内即使缓存过期也是使用该缓存                             |
        | min-fresh = 30 | 希望在30秒内获取最新响应（30秒内刷新一次）                   |
        
        
     
     若两者同时存在，cache-control的优先级更高，优先级低的会被覆盖。强缓存不关心服务器端的数据是否更新，而是通过判断数据存储时间是否在某一个时间段或者说超出某个时间就失效。
     
10. 协商缓存

    即强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识来决定是否使用缓存的过程。
    
    主要有以下两种情况：
    
    1. 协商缓存生效，返回304和Not Modified，一般读取本地请求的话基本都是使用的这种
    2. 失效，返回200和请求结果。
    
    可以通过设置两种请求头实现：Etag和Last-Modified
    
    浏览器在第一次访问资源时，会在response header中添加Last-Modified: xxx，后面的值是这个资源在服务器的最后修改时间，浏览器接收后会缓存文件和header。
    
    
    
    
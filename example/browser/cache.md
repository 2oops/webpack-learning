1. 数据请求的步骤：发起请求 => 后端处理 => 浏览器响应

2. 缓存位置：

     Service Worker

       Memory Cache

       Disk Cache

       Push Cache

  3. Service Worker

       其中涉及到请求拦截，故须使用HTTPS，与浏览器内置缓存有所不同，Service worker可以自由控制缓存文件，匹配

       和读取缓存，并且是持续性的。

        使用：先注册，后监听install事件，后即可缓存需要的文件；若service worker没有命中缓存，则按缓存优先级获取数

       据，但浏览器最终显示的还是从servie worker中获取的数据。

  4. Memory Cache

       读取比磁盘缓存快，主要缓存的是当前页面的样式/脚本/图片等，读取高效但是可持续性很短，随着页面的关闭会关

       闭线程，内存中的缓存也随即失效。

       tips: 内存缓存不关心HTTP的cache-control的值，校验可能会对多个参数的特征进行校验。

  5. Disk Cache

       与内存缓存的区别在于时效更长和容量更大。

       根据请求头字段判断哪些数据需要缓存，大文件一般不进内存而进磁盘，内存使用率高时，一般会使用磁盘

  6. Push Cache

       Http/2中内容，当前面三种方法都没有命中缓存时，才会被使用，只在会话中存在，会话关闭则释放缓存，缓存时间

       短（5M），并非严格遵守请求头字段要求的缓存条件，且缓存的内容只能被使用一次。

7. 浏览器缓存策略一般分为两种：强缓存和协商缓存，且基本都是通过请求头来设置的。

     (根据客户端是否要向服务器重新发起HTTP请求区分)

8. 缓存过程：

     浏览器每次发起HTTP请求之前都会在缓存中查找结果和缓存标识；

     浏览器每次拿到请求结果之后都会将需要缓存的结果和缓存标识放入到缓存中；

9. 强缓存
     network -> served from momory cache/ served form disk cache

     强缓存可以通过设置请求头的 expires 和 cache control 实现

     1. Expires 

        Http/1 的产物，但受限于本地时间，本地时间修改后，缓存可能失效。表示在这个时间点后，需要重新请求。

        这是一种过时的产物，现在还配置这个参数多为了兼容。

     2. Cache Control

        Http/1.1 ，主要用于控制网页缓存，

        Cache-Control: max-age=300; 即表示这个请求的正确返回后的5分钟内如果再要获取这个数据就会命中该缓存。
   
        Cache-control设置
   
        | 参数           | 作用                                                         |
        | -------------- | ------------------------------------------------------------ |
        | public         | 响应可以被客户端和代理服务器缓存                             |
        | private        | 响应只可以被客户端缓存                                       |
        | max-age = 30   | 缓存30秒后就过期，需重新请求                                 |
        | s-maxage = 30  | 覆盖max-age，只在代理服务器中生效                            |
        | no-store       | 不缓存任何响应，都从服务器获取                               |
        | no-cache       | 可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用 |
        | max-stale = 30 | 30秒内即使缓存过期也是使用该缓存                             |
        | min-fresh = 30 | 希望在30秒内获取最新响应（30秒内刷新一次）                   |
        
        
     
     若两者同时存在，cache-control的优先级更高，优先级低的会被覆盖。强缓存不关心服务器端的数据是否更新，而是通过判断数据存储时间是否在某一个时间段或者说超出某个时间就失效。
     
10. 协商缓存

    即强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识来决定是否使用缓存的过程。
    
    主要有以下两种情况：
    
    1. 协商缓存生效，返回304和Not Modified，一般读取本地请求的话基本都是使用的这种
    2. 失效，返回200和请求结果。
    
    可以通过设置两种请求头实现：Etag和Last-Modified
    
    **Last-Modified:**
    
    浏览器在第一次访问资源时，会在response header中添加Last-Modified: xxx，后面的值是这个资源在服务器的最后修改时间，浏览器接收后会缓存文件和header。
    
    浏览器下次请求该资源的时候，若检测到header中有Last-Modified这个值，将添加If-Modified-Since这个字段，值就是Last-Modified的值，服务器再次接收到这个请求后，拿这个值和资源的最后修改时间作比较，如果时间是一样的，则返回304和空响应体，内容从缓存中读取，如果时间有更新，则返回200和新的资源。
    
    Last-Modified的弊端：
    
    1. 如果本地打开了缓存文件，即使不修改，Last-Modified的值也会改变，从而导致服务器不能命中缓存导致发送相同的资源；
    2. Last-Modified是以秒计时，如果在某种情况下，可以在秒级操作数据，值不改变，服务端会认为资源命中了，从而不返回正确的资源。
    
    **Etag:**
    
    Etag是服务器响应请求是，服务器生成的一个对当前文件的唯一标识，只要文件有变化，这个值就会重新生成。
    
    浏览器在下一次加载该资源时，会将上一次返回的Etag值放在请求头的If-None-Match里面，服务器拿到后去比较，若匹配，则返回304和空响应体，不匹配则返回200和新的资源。
    
    **对比：**
    
    1. 精度上`Etag`精确度更高一点，如果是负载均衡中的服务器，生成的Last-Modified的值可能还不一致
    2. 性能上，Etag需要计算出一个hash值，而Last-Modified只需要记录时间
    3. 优先级上，服务器会优先考虑校验Etag

11. 缓存机制

    强缓存优先与协商缓存，换个思路就是说，能不发请求就不发请求，若强缓存不生效则使用协商缓存(`Last-Modified/If-Modified-Sice和Etag/If-None-Match`)，协商缓存由服务器决定是否使用缓存，如果协商缓存再失效，则代表该资源的所有缓存失效，返回200，重新返回资源和缓存标识。

    若没有设置缓存策略，则浏览器一般默认使用请求的Date值减去Last-Modified值后的结果的10%作为缓存时间。

12. 实际应用场景

    1. 频繁变动的资源

       可以设置no-cache使其每次都去请求资源，配置Etag等的匹配，虽不能减少请求数量，但是响应数据减少了

    2. 不常变化的资源

       配置很大的max-age值，如在线的类库都是使用文件名或路径中加hash的方式以更改URL，从而让强制缓存失效（不再使用）

13. 用户行为对浏览器缓存的影响
    1. 普通操作：访问网址，查找disk-cache，有则使用，没有的话去请求
    2. F5: tab页没哟关闭，memory-cache可用，匹配的话会优先使用，然后才是disk-cache
    3. Ctrl+F5: 不使用缓存，发送的请求头均带有no-cache(兼容方案下还会添加Pragma: no-cache)，服务器返回最新内容。





